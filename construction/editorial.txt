Subtask: Find the maximum flow given that the path length must be at most K
We simply do binary search on the flow, and use dijstkra to determine whether it is possible to get a path length less than or equal to K. We do NlogN dij every iteration of binary search, so the complexity for this subtask is Nlog^2(N)

Solution for the Problem: 
The tricky part is that one edge can be deleted and we must look for the worst possible scenario. Assume for now that no edge is deleted; call the main path from node 1 to node N 'm'. To get our desired answer, we wish to go through each edge on 'm' and compute the minimum path length that doesn't use that edge. We then take the maximum out of all of these lengths, and check if it is less than K.

Look at another edge 'e' not in 'm'; note that the shortest path from 1 to n through 'e' will use a prefix and suffix of 'm'. In other words there is an interval of edges in main path which the alternate path through 'e' does not use. The reason for this is because it is never optimal to diverge from 'm' and then come back unless it is to include 'e'. Call this interval which the path through 'e' doesn't go through 'm' the "interval of divergence" or IOD, which can be found for each edge using a 2nd dijsktras.

We must iterate through all the edges not on 'm', and get the IOD for each edge along with the minimum path length to go through that edge from 1 to n. To get the minimum length of a path not using an edge 'f' in path 'm', we must query for each edge 'e' not in 'm' which has an IOD containing 'f' (i.e. the path through 'e' doesn't use edge 'f'). Iterating through each edge and checking its IOD is obviously too slow, so we use a segment tree to store all this information, where each node represents the minimum path length without using that interval of edges on the main path. Each update will be a range and specify a minimum path length over that IOD. We will then have point queries, where we look at each interval and see if it includes the queried edge, and get the minimum of them. We do this with every edge on 'm'.

Because each operation on the segment tree is logN and there are at most M operations per binary search, the complexity is Mlog^2(N).

#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <algorithm>
using namespace std;
#define MAXN 50001
vector<int> adj[MAXN];
map<pair<int, int>, int> wt, flow, ind;
map<pair<int, int>, bool> is_path;
vector<pair<int, int> > edges, path;
int dist[MAXN], end_dist[MAXN], par[MAXN], npar[MAXN], st[4*MAXN], llast[MAXN], rfirst[MAXN];
int N, M, K;

void update(int l, int r, int ul, int ur, int si, int val)
{
	if (ul <= l && r <= ur)
	{
		st[si] = min(st[si], val);
		return;
	}
	if (ul > r || l > ur) return;

	int m = (l + r) / 2;
	update(l, m, ul, ur, 2 * si + 1, val);
	update(m + 1, r, ul, ur, 2 * si + 2, val);
}

int query(int l, int r, int si, int e)
{
	if (l == r) return st[si];

	int m = (l + r) / 2;
	return min(st[si], e < m ? query(l, m, 2 * si + 1, e) : query(m + 1, r, 2 * si + 2, e));
}

bool init_dij(int min_flow, int n)
{
	set<pair<int, int> > vis;
	end_dist[n] = 0;
	vis.insert({ 0, n });

	while (vis.size())
	{
		int curr = vis.begin()->second;
		vis.erase(vis.begin());
		if (!curr) return true;

		for (int c : adj[curr])
		{
			if (c == par[curr]) continue;
			if ((end_dist[c] == 33686018 || end_dist[curr] + wt[{curr, c}] < end_dist[c]) && flow[{curr, c}] >= min_flow)
			{
				end_dist[c] = end_dist[curr] + wt[{curr, c}];
				vis.insert({ end_dist[c], c });
				par[c] = curr;
			}
		}
	}

	return false;
}

void main_dij(int min_flow, int n)
{
	set<pair<int, pair<int, int> > > vis;
	vis.insert({ 0, { n, -1 }});

	if (n == N - 1)
	{
		end_dist[n] = 0;
		while (vis.size())
		{
			int curr = vis.begin()->second.first;
			int prev = vis.begin()->second.second;
			vis.erase(vis.begin());

			for (int c : adj[curr])
			{
				if (c == par[curr]) continue;
				if (flow[{curr, c}] < min_flow) continue;

				if (prev == -1 && !is_path[{n, c}])
				{
					rfirst[ind[{n, c}]] = path.size();
					rfirst[ind[{c, n}]] = path.size();
				}
				else if (!is_path[{n, c}])
				{
					rfirst[ind[{n, c}]] = rfirst[ind[{ prev, n }]];
					rfirst[ind[{c, n}]] = rfirst[ind[{ prev, n }]];
				}

				if (end_dist[c] == 33686018 || end_dist[curr] + wt[{curr, c}] < end_dist[c])
				{
					end_dist[c] = end_dist[curr] + wt[{curr, c}];
					vis.insert({ end_dist[c], { c, n } });
					par[c] = curr;
				}
			}
		}
	}
	else
	{
		dist[n] = 0;
		while (vis.size())
		{
			int curr = vis.begin()->second.first;
			int prev = vis.begin()->second.second;
			vis.erase(vis.begin());

			for (int c : adj[curr])
			{
				if (c == par[curr]) continue;
				if (flow[{curr, c}] < min_flow) continue;

				if (prev == -1 && !is_path[{n, c}])
				{
					llast[ind[{n, c}]] = -1;
					llast[ind[{c, n}]] = -1;
				}
				else if (!is_path[{n, c}])
				{
					llast[ind[{n, c}]] = llast[ind[{ prev, n }]];
					llast[ind[{c, n}]] = llast[ind[{ prev, n }]];
				}
				if ((dist[c] == 33686018 || dist[curr] + wt[{curr, c}] < dist[c]))
				{
					dist[c] = dist[curr] + wt[{curr, c}];
					vis.insert({ dist[c], { c, n } });
					npar[curr] = c;
				}
			}
		}
	}
}

int main() {
	ifstream cin("dij_bin.txt");

	cin >> N >> M >> K;

	for (int i = 0; i < M; i++)
	{
		int a, b, w, f;
		cin >> a >> b >> w >> f;

		adj[--a].push_back(--b);
		adj[b].push_back(a);
		edges.push_back({ a, b });
		edges.push_back({ b, a });
		ind[{a, b}] = edges.size() - 2;
		ind[{b, a}] = edges.size() - 1;

		wt[{a, b}] = w;
		wt[{b, a}] = w;
		flow[{a, b}] = f;
		flow[{b, a}] = f;
		is_path[{a, b}] = false;
		is_path[{b, a}] = false;
	}

	int lo = 0;
	int hi = 1e6;
	while (lo + 1 < hi)
	{
		int m = (lo + hi) / 2;

		//reset everything
		path.clear();
		is_path.clear();
		memset(par, -1, sizeof par);
		memset(npar, -1, sizeof npar);
		memset(end_dist, 2, sizeof end_dist);
		memset(dist, 2, sizeof dist);
		memset(st, 2, sizeof st);

		if (!init_dij(m, N - 1))
		{
			hi = m;
			continue;
		}

		int n = 0;
		while (n != N - 1)
		{
			int prev = n;
			n = par[n];

			if (n == prev) break;
			path.push_back({ prev, n }); 
			is_path[{ prev, n }] = true;
			is_path[{ n, prev }] = true;

			llast[ind[{n, prev}]] = path.size() - 2;
			llast[ind[{prev, n}]] = path.size() - 2;
			rfirst[ind[{n, prev}]] = path.size() - 1;
			rfirst[ind[{prev, n}]] = path.size() - 1;
		}

		memset(par, -1, sizeof par);
		memset(npar, -1, sizeof npar);
		memset(end_dist, 2, sizeof end_dist);
		memset(dist, 2, sizeof dist);
		main_dij(m, N - 1);
		main_dij(m, 0);

		for (int i = 0; i < edges.size(); i++)
			update(0, N - 1, llast[i] + 1, rfirst[i], 0, dist[edges[i].first] + wt[edges[i]] + end_dist[edges[i].second]);

		int bin_ans = 0;
		for (int i = 0; i < path.size(); i++)
			bin_ans = max(bin_ans, query(0, N - 1, 0, i));

		if (bin_ans > K)
			hi = m;
		else
			lo = m;
	}

	cout << lo << "\n";
	return 0;
}

