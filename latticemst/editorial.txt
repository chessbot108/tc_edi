
tl;dr, find the sums of all the max distances of a point to the corner in O(dlogMOD) then subtract the sum of all Di^k * (2 ^ (d - 1)) from that, then sort the D array and add for(int i = 0; i<d-1; i++) sum of all Di^k except for D[i], and you add (D[i]/2)^k to that.

So notes, the original problem had d = k = 2, and D[1] * D[2] <= 1e6. PurpleCrayon saw this and made it harder, but all observations stem from solving the d = k = 2 case. For now, lets define a few terms that will be used throughout this

for d = k = 2,
n = D[1], m = D[2]

So for d = k = 2, the key observation is that the furthest point for any point on the lattice is one of the 4 corners. This gives us a basically O(4*n*m) algorithm (which isnt perfect, but we'll get to that later). Then the next observation is that n and m can be made independent. So we can have the answer be sigma(i = 1, n) sigma(j = 1, m) max(i, n - i)^2 + max(j, m -j )^2. Ignore the off-by-ones in here (and later in the editorial as well, they arent that important and the cancer impl is left to you :D). now since the terms max(i, n - i)^2 and max(j, m - j)^2 are independent we can take it out of the sigma. So now we have n * sigma(i = 1, m) max(i, m - i)^2 + m * sigma(i = 1, n) max(i, n - i)^2. You can see that the sigma will look something like (n)^2 + (n - 1)^2 + (n - 2)^2 ... (n/2 +1)^2 + (n/2)^2 + (n/2 +1)^2 ... (n - 1)^2 + (n)^2. There is some casework on the cases for n is odd/even, but that is left as an exercise to the reader :D. So from here, we can make it something like 2 * (sum of squares(n) - sum of squares to (n/2)). Yet again the casework is left as an exercise to the reader. 

Now, this is not complete. If you were paying attention we have added n^2 edges now and more importantly, the edges between the corners are duplicates. There are two edges from (1, 1) to (n, m) and two from (n, 1) to (1, m). So we have to remove the extra corner edges and add 1 more to maximize our MST. Just note that this doesnt make our algorithm completely wrong, the change is relatively trivial. So now it would help to visualize a 4x4 lattice with all the edges to the furthest corner except the edges between corners themselves. Then you can connect the two pairs of opposite corners. Now you have to add one edge in between the two connected components to maximize the distance. you would add an edge from (1, 1) to (4, 2), or any rotation of such an edge. The reasoning is that (4, 2) or (2, 4) is the furthest point from (1, 1) in a different connected component. So as a whole you would go either from (1, 1) to (n, m/2) or (n/2, m), all casework is left to the reader. So that concludes our solution for a 2d problem. It can be done in O(1) by first finding the sum described in the first paragraph, subtracting (n^2 + m^2) *2 for the extra edges and adding max((n/2)^2 + m^2, (m/2)^2 + n^2).

But wait, this is 2d with d = 2, how do I generalize it to d dimensions and k powers. So lets do k powers first. You just have to know how to find the sum of 1^k + 2^k + 3^k ... + n^k. This can be done with interpolation in O(k*logMOD) or O(k). I will try describing it here but https://codeforces.com/blog/entry/82953 explains it a lot better. So the idea is, you have k points (1, 1^k), (2, 1^k + 2^k), (3, 1^k + 2^k + 3^k) ... (n, 1^k+...n^k) + (n+1, 1^k+...(n+1)^k), (n+2, 1^k+...(n+2)^k) and you want to find the polynomial that goes through all of these points and has degree k+1. This can be done with Lagrange interpolation. Refer to the above blog to get how Lagrange interpolation works. So then you have to evaluate it for x=n and find what y is. With some math magic, it can be done :). Just refer to the above article and solution for F on this as well: https://codeforces.com/blog/entry/23442. So now lets define the eval(n, k) as sum of n^k + (n-1)^k + (n-2)^k ... (n/2 +1)^k + (n/2)^k + (n/2 +1)^k ... (n-1)^k + n^k. Casework is left to the reader, but this is the result of sigma(i=1, n) max(i, n-i)^k. Also with the casework to the reader :). The eval function would then be: (sum of powers(n, k) - sum of powers(n/2, k))*2 with some casework for the reader :). And this is generalizing it for k powers. Dont worry, we havent gotten to fun part yet.

Some new definitions:
P = the product of all Di
X = the sum of Di^k of all Di


Now for d dimensions, if you hate this, go spam PurpleCrayon about it. So the general idea is that since each dimension is more or less independent of each other you can find the answer for each dimension, sum them up, and then solve the case of corner edges (hahah corner case...get it...). So for each dimension, you find eval(D[i]) then multiply it by all of the other dimensions. Just imagine a d nested for loops/sigmas and then taking each part out of it. So for now lets say ans = sigma(i=1, n) eval(D[i]) * P/D[i]. Hopefully, this part is straightforward, if not just try visualizing/drawing for 3d. But what about the corners...

So there are 2^d "corners" or vertices (I'll call them corners) on a d dimensional prismlike figure. 4 on a 2d square, 8 on a 3d cube. So that makes 2^(d-1) of the corner edges duplicates. So now we should subtract 2^(d-1) * X from ans then add back in 2^(d-1) -1 edges to make it an mst again. So now it would help to imagine a 2x3x3 lattice with the 3x3 side facing up. So will first draw 4 edges between the pairs of corners then add 3 more for an MST. So its obvious adding edges across the 3x3 face is optimal, but you can only add 2 before it makes a cycle. So the result is you add 2 edges along the 3x3 side and 1 edge from (1, 1, 1) to (ceil(3/2), 2, 3) or (2, 2, 3). So to generalize it, you would pick the smallest of the three dimensions and add (n/2)^k + m^k + l^k twice and take the second smallest and add n^k + (m/2)^k + l^k once for 3 edges. And for d dimensions, assuming D is sorted, you would want, sigma(i=1, d-1) 2^(d - i -1) * (X + (D[i]/2)^k - D[i]^k). Of course with some casework to the reader. So the idea would be to take as much of the largest edge, then the second largest, ... and so on until its an mst. Picking the smallest D[i] to halve is optimal by some proof of greedy (which is left to the reader). 

Complexity O(d*k) or O(d*k*logMOD) depending on how you handle inverses with binpow or prefix/suffix. d dimensions and klogMOD per dimension. 

I also wrote 2d, 3d, and 4d, kruskals to check my work :). 


